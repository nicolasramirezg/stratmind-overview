import uuid
from typing import Optional, List, Dict, Set
from dataclasses import dataclass, field

class Status:
    """
    Enum-like class for task status values.
    """
    PENDING = "pending"
    IN_PROGRESS = "in-progress"
    DONE = "done"
    VALID = {PENDING, IN_PROGRESS, DONE}

@dataclass
class Task:
    """
    Represents a task within a hierarchical agent-based execution system.

    Each task can have:
    - Nested subtasks (parent-child hierarchy)
    - Explicit execution dependencies
    - Assignment to a functional area and/or agent
    - An input prompt and result generated by an LLM

    Output: Tree structure with dependency control and full serialization.

    Example usage:
        t = Task(title="Design campaign", description="...", expected_output="...")
        t.add_subtask(Task(...))
        t.add_dependency(other_task)
    """

    title: str
    description: str
    expected_output: str
    area: Optional[str] = None
    parent: Optional['Task'] = None
    assigned_agent: Optional[str] = None
    status: str = Status.PENDING
    responsibilities: Optional[List[str]] = field(default_factory=list)
    task_id: str = field(default_factory=lambda: str(uuid.uuid4()), init=False)
    dependencies: Set['Task'] = field(default_factory=set, repr=False)
    subtasks: List['Task'] = field(default_factory=list, repr=False)
    intro: Optional[str] = None
    execution_type: str = "llm"
    prompt: Optional[Dict[str, str]] = None
    result: Optional[str] = None
    manager: Optional['TaskManager'] = None

    def __post_init__(self):
        """
        Validates the status after initialization.
        """
        if self.status not in Status.VALID:
            raise ValueError(f"Invalid status: {self.status}")

    def __hash__(self):
        """
        Allows Task objects to be used in sets and as dict keys.
        """
        return hash(self.task_id)

    def __eq__(self, other):
        """
        Checks equality based on unique task_id.
        """
        if not isinstance(other, Task):
            return False
        return self.task_id == other.task_id

    def add_subtask(self, subtask: 'Task') -> None:
        """
        Adds a subtask as a child of this task and sets its parent reference.

        Args:
            subtask (Task): The subtask to add.
        """
        subtask.parent = self
        self.subtasks.append(subtask)

    def add_dependency(self, dep: 'Task') -> None:
        """
        Adds a dependency. This task depends on 'dep' being completed first.
        Detects cycles and raises an exception if a circular dependency is found.

        Args:
            dep (Task): The dependency to add.
        """
        if self.depends_on(dep):
            raise ValueError("Circular dependency detected")
        self.dependencies.add(dep)

    def depends_on(self, other: 'Task', visited: Optional[Set['Task']] = None) -> bool:
        """
        Recursively checks if this task depends on 'other'.

        Args:
            other (Task): The task to check dependency against.
            visited (set, optional): Set of already visited tasks to avoid infinite recursion.

        Returns:
            bool: True if this task depends on 'other', False otherwise.
        """
        if visited is None:
            visited = set()
        if other in self.dependencies:
            return True
        visited.add(self)
        for d in self.dependencies:
            if d not in visited and d.depends_on(other, visited):
                return True
        return False

    def to_dict(self) -> Dict:
        """
        Serializes the task, including dependencies, subtasks, and prompt/result.

        Returns:
            dict: Serialized representation of the task.
        """
        return {
            "task_id": self.task_id,
            "title": self.title,
            "description": self.description,
            "expected_output": self.expected_output,
            "area": self.area,
            "responsibilities": self.responsibilities,
            "assigned_agent": self.assigned_agent,
            "status": self.status,
            "intro": self.intro,
            "execution_type": self.execution_type,
            "prompt": self.prompt,
            "result": self.result,
            "dependencies": [d.task_id for d in self.dependencies],
            "subtasks": [s.to_dict() for s in self.subtasks],
            "parent_task_id": self.parent.task_id if self.parent else None,
        }

class TaskManager:
    """
    Manages the creation, hierarchy, and dependencies of multiple tasks.

    Key functionalities:
    - Create tasks and subtasks linked by ID
    - Register all tasks and their status
    - Resolve execution order based on dependencies (topological order)
    - Serialize the complete task system as an exportable dictionary

    Output: Complete dictionary of tasks with resolved subtasks and dependencies.

    Example usage:
        manager = TaskManager()
        t1 = manager.create_task("Main", "...", "...")
        t2 = manager.create_task("Sub", "...", "...", parent_id=t1.task_id)
        manager.add_dependency(t2.task_id, t1.task_id)
    """

    def __init__(self):
        """
        Initializes the TaskManager.
        """
        self.tasks = {}
        self.root_task_id = None

    def create_task(
        self,
        title: str,
        description: str,
        expected_output: str,
        area: Optional[str] = None,
        parent_id: Optional[str] = None,
        assigned_agent: Optional[str] = None,
        status: str = Status.PENDING,
        responsibilities: Optional[List[str]] = None,
        execution_type: str = "llm"
    ) -> Task:
        """
        Creates a task and registers it in the manager.
        If parent_id is provided, adds it as a subtask.

        Args:
            title (str): Task title.
            description (str): Task description.
            expected_output (str): Expected output for the task.
            area (str, optional): Functional area.
            parent_id (str, optional): Parent task ID.
            assigned_agent (str, optional): Assigned agent.
            status (str): Task status.
            responsibilities (list, optional): List of responsibilities.
            execution_type (str): Execution type ("llm" or other).

        Returns:
            Task: The created task object.
        """
        task = Task(
            title=title,
            description=description,
            expected_output=expected_output,
            area=area,
            assigned_agent=assigned_agent,
            status=status,
            responsibilities=responsibilities or [],
            execution_type=execution_type,
            manager=self
        )
        self.tasks[task.task_id] = task
        # If no parent, this is the root task
        if parent_id is None:
            self.root_task_id = task.task_id
        if parent_id:
            parent = self.tasks.get(parent_id)
            if parent:
                parent.add_subtask(task)
        return task

    def add_dependency(self, task_id: str, dep_id: str) -> None:
        """
        Adds a dependency between two registered tasks.

        Args:
            task_id (str): The dependent task's ID.
            dep_id (str): The dependency task's ID.
        """
        t, d = self.tasks[task_id], self.tasks[dep_id]
        t.add_dependency(d)

    def get_execution_order(self) -> List[Task]:
        """
        Returns a topologically sorted list of tasks based on dependencies.
        Raises an exception if a cycle is detected.

        Returns:
            list: List of tasks in execution order.
        """
        visited = {}
        order: List[Task] = []

        def visit(t: Task):
            if visited.get(t.task_id) == 'temp':
                raise ValueError('Circular dependency detected during ordering')
            if visited.get(t.task_id) is None:
                visited[t.task_id] = 'temp'
                for dep in t.dependencies:
                    visit(dep)
                visited[t.task_id] = 'perm'
                order.append(t)

        for task in self.tasks.values():
            if visited.get(task.task_id) is None:
                visit(task)

        return order

    def to_dict(self) -> Dict[str, Dict]:
        """
        Serializes all tasks to a dictionary.

        Returns:
            dict: Dictionary of all tasks, keyed by task_id.
        """
        return {tid: t.to_dict() for tid, t in self.tasks.items()}

def create_and_link_subtasks(subtasks, area, area_task, task_manager):
    """
    Creates Task objects for each subtask and assigns dependencies using normalized titles.
    Returns a dictionary {normalized_title: Task}.

    Args:
        subtasks (list): List of subtask dicts.
        area (str): Area name.
        area_task (Task): The parent area task.
        task_manager (TaskManager): The manager instance.

    Returns:
        dict: Mapping from normalized subtask title to Task object.
    """
    subtask_objs = {}
    for subtask in subtasks:
        t = task_manager.create_task(
            title=subtask["title"],
            description=subtask["description"],
            expected_output=subtask["expected_output"],
            area=area,
            parent_id=area_task.task_id,
            execution_type=subtask.get("execution_type", "llm")
        )
        # Ensure the child is in the parent's subtask list
        if t not in area_task.subtasks:
            area_task.subtasks.append(t)
        t.parent = area_task
        subtask_objs[subtask["title"].strip().lower()] = t

    for subtask in subtasks:
        dependencies = subtask.get("dependencies", [])
        for dep_title in dependencies:
            dep_task = subtask_objs.get(dep_title.strip().lower())
            if dep_task:
                subtask_objs[subtask["title"].strip().lower()].add_dependency(dep_task)
    return subtask_objs
